using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace AdventOfCode2020.Day14
{
    /// <summary>
    /// Solution Wrapper Class for Advent of Code 2020 Day 14
    /// </summary>
    internal class AdventDay14Solution
    {
        DockingSystem dockSystem;

        /// <summary>
        /// Constructor.
        /// Load data from a file.
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="loadingBehavior">Composition</param>
        public AdventDay14Solution(string fileName, LoadingDockingData? loadingBehavior = null)
        {
            if (loadingBehavior == null) loadingBehavior = new DataLoadingPart1();
            dockSystem = new DockingSystem(loadingBehavior);
            dockSystem.LoadDockingData(fileName);
        }

        /// <summary>
        /// Constructor
        /// Load Data from string array with each element represents a line.
        /// </summary>
        /// <param name="lines"></param>
        /// <param name="loadingBehavior">Composition</param>
        public AdventDay14Solution(string[] lines, LoadingDockingData? loadingBehavior = null)
        {
            if (loadingBehavior == null) loadingBehavior = new DataLoadingPart1();
            dockSystem = new DockingSystem(loadingBehavior);
            dockSystem.LoadDockingData(lines);
        }

        /// <summary>
        /// Method: GetSolution1
        /// returns the sum of docking data loaded from texts.
        /// </summary>
        /// <returns></returns>
        public long GetSolution1()
        {
            return dockSystem.SumOfDockingData();
        }
    }

    /// <summary>
    /// Type: BitMask
    /// Handles Advent of Code 2020 Vacation Ferry Docking Masks
    /// </summary>
    internal class BitMask
    {
        char[] value = new char[36]; // Textual input from the dock.
        long ones, zeros; // Ones and Zeros from the mask.

        public BitMask(string value)
        {
            this.value = value.Reverse().ToArray(); // Let's start from the least significant bit.

            ones = 0;
            zeros = 0;

            for (int i = 0; i < this.value.Length; i++)
            {
                switch (this.value[i])
                {
                    case '0':
                        zeros |= (1L << i); // Mark the bit position with ON
                        break;
                    case '1':
                        ones |= (1L << i); // Mark the bit position with ON
                        break;
                    default:
                        break;
                }
            }
            zeros = -1 ^ zeros; // Let's make the zeros actual zeros by flipping.
        }

        /// <summary>
        /// Method: MaskValue
        /// Part1 Masking Task.
        /// Both Zeros and Ones are forced onto the values...
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public long MaskValue(long value)
        {
            return (value & zeros) | ones;
        }

        /// <summary>
        /// Method: BuikldXAddresses
        /// Recursive function that generates X amount of addresses with masking procedure.
        /// X is generated by 2^(number of X in the mask)
        /// </summary>
        /// <param name="address"></param>
        /// <param name="list"></param>
        /// <param name="currentBit"></param>
        /// <returns>Returns the X, the number of addresses generated.</returns>
        protected int BuildXAddresses(long address, List<long> list, int currentBit = 35)
        {
            /// BASE CASE
            if(currentBit < 0)
            {
                list.Add(address); // add a formulated address and return 1 since one address generated.
                return 1;
            }
            else
            {
                switch (this.value[currentBit])
                {
                    case 'X':
                        /// We have encountered the X, lets split up into two branches (X represenst both 0 and 1)
                        return BuildXAddresses(address | (1L << currentBit), list, currentBit - 1)
                                + BuildXAddresses(address & ~(1L << currentBit), list, currentBit - 1);
                    case '1':
                        /// Ones are forced upon the address.
                        return BuildXAddresses(address | (1L << currentBit), list, currentBit - 1);
                    default:
                        /// We are really talking about zeros here... No changes required.
                        return BuildXAddresses(address, list, currentBit - 1);
                }
            }
        }

        /// <summary>
        /// Method: MaskAddress
        /// Part2 requirement, we are masking address, not the value.
        /// This method generates a collection of addresses for the value to be pushed on.
        /// </summary>
        /// <param name="memoryAddress"></param>
        /// <returns></returns>
        public List<long> MaskAddress(long memoryAddress)
        {
            var addr = new List<long>();

            BuildXAddresses(memoryAddress, addr);

            return addr;
        }
    }

    /// <summary>
    /// Type: Docking Parameter
    /// Contains the memory location (ID) and value.
    /// </summary>
    public class DockingParam
    {
        public long ID { get; set; }

        public long Value { get; set; }

        public DockingParam(long ID, long value)
        {
            this.ID = ID;
            this.Value = value;
        }
    }

    /// <summary>
    /// Interface: LodaingDockingData
    /// Strategy Pattern (Composition)
    /// Subsequent class can determine how the data are translated with the masks provided from the dock.
    /// </summary>
    interface LoadingDockingData
    {
        public Dictionary<long, DockingParam> Load(string[] lines);
    }

    /// <summary>
    /// Composition: DataLoading for Part 1
    /// </summary>
    internal class DataLoadingPart1 : LoadingDockingData
    {
        /// <summary>
        /// Helper Method: IsMask
        /// checks whether the input string contains the keyword "mask"
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        protected bool IsMask(string text)
        {
            if (text.Contains("mask")) return true;
            else return false;
        }

        /// <summary>
        /// Method: Load
        /// </summary>
        /// <param name="lines"></param>
        /// <returns></returns>
        public Dictionary<long, DockingParam> Load(string[] lines)
        {
            var dockingData = new Dictionary<long, DockingParam>();
            BitMask mask = new BitMask("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");

            foreach (var line in lines)
            {
                if (IsMask(line))
                            // If the line is for a mask
                {
                    var temp = line.Replace("mask", "").Replace("=", "").Replace(" ", "");
                    mask = new BitMask(temp); // create a mask
                }
                else
                            // If the line is for a value
                {
                    string[] numbers = Regex.Split(line, @"\D+");
                    long id = long.Parse(numbers[1]); // extracting the memory location
                    long value = long.Parse(numbers[2]); // extracting the value

                    UpdateDockingData(id, mask.MaskValue(value)); // let's put it in the memory (hashtable)
                }
            }

            return dockingData; // return the reference value of the hashtable created.

            /// Helper Method
            void UpdateDockingData(long id, long value)
            {
                if (dockingData.ContainsKey(id))
                            /// if the memory location is already allocated,
                            /// simply update the value.
                {
                    dockingData[id].Value = value;
                }
                else
                            /// if the memory isn't allocated, allocate it with the value.
                {
                    dockingData.Add(id, new DockingParam(id, value));
                }
            }
        }
    }

    /// <summary>
    /// Composition: Data Loading for Part 2
    /// </summary>
    internal class DataLoadingPart2 : LoadingDockingData
    {
        /// <summary>
        /// Helper Method: IsMask
        /// checks whether the input string contains the keyword "mask"
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        protected bool IsMask(string text)
        {
            if (text.Contains("mask")) return true;
            else return false;
        }

        public Dictionary<long, DockingParam> Load(string[] lines)
        {
            var dockingData = new Dictionary<long, DockingParam>();
            BitMask mask = new BitMask("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
            //LogStat log = new LogStat(); /* logging */

            foreach (var line in lines)
            {
                if (IsMask(line)) /// For Mask
                {
                    var temp = line.Replace("mask", "").Replace("=", "").Replace(" ", "");
                    mask = new BitMask(temp); // create the mask

                    //log.Append($"Mask : {temp}\n"); /* logging */
                }
                else /// For value
                {
                    string[] numbers = Regex.Split(line, @"\D+");
                    long id = long.Parse(numbers[1]); // extract memory address
                    long value = long.Parse(numbers[2]); // extract the value
                    UpdateDockingData(mask.MaskAddress(id), value); // let's put it in the memory.
                }
            }

            //log.LogOnFile(); /* logging */

            return dockingData;

            void UpdateDockingData(List<long> addr, long value)
            {
                /// Iterate through Masked collection of addresses.
                foreach(var id in addr)
                {
                    if (dockingData.ContainsKey(id))
                        /// if the memory location is already in use.
                    {
                        dockingData[id].Value = value;

                        //log.Append($"MEM[{id}] {value} *UPDATE*\n"); /* logging */
                    }
                    else /// if the memory location hasn't been allotted.
                    {
                        dockingData.Add(id, new DockingParam(id, value));

                        //log.Append($"MEM[{id}] {value}\n"); /* logging */

                    }
                }
            }
        }
    }

    /// <summary>
    /// Type: DockingSystem
    /// Handles the sequences of masks and data values between the dock and the ferry.
    /// </summary>
    internal class DockingSystem
    {
        // Fields
        Dictionary<long, DockingParam> dockingData = new Dictionary<long, DockingParam>();
        LoadingDockingData loadingBehavior;

        /// <summary>
        /// Constructor
        /// Requires the loading behavior for the sequence.
        /// </summary>
        /// <param name="loadingBehavior"></param>
        public DockingSystem(LoadingDockingData loadingBehavior)
        {
            this.loadingBehavior = loadingBehavior;
        }

        /// <summary>
        /// Method: LoadDockingData
        /// loads from a file.
        /// </summary>
        /// <param name="fileName"></param>
        public void LoadDockingData(string fileName)
        {
            var fname = Path.Combine(System.Environment.CurrentDirectory, fileName);
            var lines = File.ReadAllLines(fname);
            LoadDockingData(lines);
        }

        /// <summary>
        /// Method: LoadDockingData
        /// loads  from a text
        /// Strategy Pattern: External Behavior Class handles the behavior.
        /// </summary>
        /// <param name="lines"></param>
        public void LoadDockingData(string[] lines)
        {
            this.dockingData = loadingBehavior.Load(lines);
        }

        /// <summary>
        /// Method: SumOfDockingData
        /// Sum of all values in the memory are returned.
        /// </summary>
        /// <returns></returns>
        public long SumOfDockingData()
        {
            long sum = 0;
            foreach(var data in dockingData.Values)
            {
                sum += data.Value;
            }
            return sum;
        }
    }

}
